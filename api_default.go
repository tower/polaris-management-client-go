/*
Polaris Management Service

Defines the management APIs for using Polaris to create and manage Iceberg catalogs and their principals

API version: 0.0.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package polarismgmt

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type DefaultAPI interface {

	/*
	AddGrantToCatalogRole Method for AddGrantToCatalogRole

	Add a new grant to the catalog role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param catalogName The name of the catalog where the role will receive the grant
	@param catalogRoleName The name of the role receiving the grant (must exist)
	@return ApiAddGrantToCatalogRoleRequest
	*/
	AddGrantToCatalogRole(ctx context.Context, catalogName string, catalogRoleName string) ApiAddGrantToCatalogRoleRequest

	// AddGrantToCatalogRoleExecute executes the request
	AddGrantToCatalogRoleExecute(r ApiAddGrantToCatalogRoleRequest) (*http.Response, error)

	/*
	AssignCatalogRoleToPrincipalRole Method for AssignCatalogRoleToPrincipalRole

	Assign a catalog role to a principal role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param principalRoleName The principal role name
	@param catalogName The name of the catalog where the catalogRoles reside
	@return ApiAssignCatalogRoleToPrincipalRoleRequest
	*/
	AssignCatalogRoleToPrincipalRole(ctx context.Context, principalRoleName string, catalogName string) ApiAssignCatalogRoleToPrincipalRoleRequest

	// AssignCatalogRoleToPrincipalRoleExecute executes the request
	AssignCatalogRoleToPrincipalRoleExecute(r ApiAssignCatalogRoleToPrincipalRoleRequest) (*http.Response, error)

	/*
	AssignPrincipalRole Method for AssignPrincipalRole

	Add a role to the principal

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param principalName The name of the target principal
	@return ApiAssignPrincipalRoleRequest
	*/
	AssignPrincipalRole(ctx context.Context, principalName string) ApiAssignPrincipalRoleRequest

	// AssignPrincipalRoleExecute executes the request
	AssignPrincipalRoleExecute(r ApiAssignPrincipalRoleRequest) (*http.Response, error)

	/*
	CreateCatalog Method for CreateCatalog

	Add a new Catalog

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateCatalogRequest
	*/
	CreateCatalog(ctx context.Context) ApiCreateCatalogRequest

	// CreateCatalogExecute executes the request
	//  @return Catalog
	CreateCatalogExecute(r ApiCreateCatalogRequest) (*Catalog, *http.Response, error)

	/*
	CreateCatalogRole Method for CreateCatalogRole

	Create a new role in the catalog

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param catalogName The catalog for which we are reading/updating roles
	@return ApiCreateCatalogRoleRequest
	*/
	CreateCatalogRole(ctx context.Context, catalogName string) ApiCreateCatalogRoleRequest

	// CreateCatalogRoleExecute executes the request
	//  @return CatalogRole
	CreateCatalogRoleExecute(r ApiCreateCatalogRoleRequest) (*CatalogRole, *http.Response, error)

	/*
	CreatePrincipal Method for CreatePrincipal

	Create a principal

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreatePrincipalRequest
	*/
	CreatePrincipal(ctx context.Context) ApiCreatePrincipalRequest

	// CreatePrincipalExecute executes the request
	//  @return PrincipalWithCredentials
	CreatePrincipalExecute(r ApiCreatePrincipalRequest) (*PrincipalWithCredentials, *http.Response, error)

	/*
	CreatePrincipalRole Method for CreatePrincipalRole

	Create a principal role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreatePrincipalRoleRequest
	*/
	CreatePrincipalRole(ctx context.Context) ApiCreatePrincipalRoleRequest

	// CreatePrincipalRoleExecute executes the request
	//  @return PrincipalRole
	CreatePrincipalRoleExecute(r ApiCreatePrincipalRoleRequest) (*PrincipalRole, *http.Response, error)

	/*
	DeleteCatalog Method for DeleteCatalog

	Delete an existing catalog. The catalog must be empty.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param catalogName The name of the catalog
	@return ApiDeleteCatalogRequest
	*/
	DeleteCatalog(ctx context.Context, catalogName string) ApiDeleteCatalogRequest

	// DeleteCatalogExecute executes the request
	DeleteCatalogExecute(r ApiDeleteCatalogRequest) (*http.Response, error)

	/*
	DeleteCatalogRole Method for DeleteCatalogRole

	Delete an existing role from the catalog. All associated grants will also be deleted

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param catalogName The catalog for which we are retrieving roles
	@param catalogRoleName The name of the role
	@return ApiDeleteCatalogRoleRequest
	*/
	DeleteCatalogRole(ctx context.Context, catalogName string, catalogRoleName string) ApiDeleteCatalogRoleRequest

	// DeleteCatalogRoleExecute executes the request
	DeleteCatalogRoleExecute(r ApiDeleteCatalogRoleRequest) (*http.Response, error)

	/*
	DeletePrincipal Method for DeletePrincipal

	Remove a principal from polaris

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param principalName The principal name
	@return ApiDeletePrincipalRequest
	*/
	DeletePrincipal(ctx context.Context, principalName string) ApiDeletePrincipalRequest

	// DeletePrincipalExecute executes the request
	DeletePrincipalExecute(r ApiDeletePrincipalRequest) (*http.Response, error)

	/*
	DeletePrincipalRole Method for DeletePrincipalRole

	Remove a principal role from polaris

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param principalRoleName The principal role name
	@return ApiDeletePrincipalRoleRequest
	*/
	DeletePrincipalRole(ctx context.Context, principalRoleName string) ApiDeletePrincipalRoleRequest

	// DeletePrincipalRoleExecute executes the request
	DeletePrincipalRoleExecute(r ApiDeletePrincipalRoleRequest) (*http.Response, error)

	/*
	GetCatalog Method for GetCatalog

	Get the details of a catalog

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param catalogName The name of the catalog
	@return ApiGetCatalogRequest
	*/
	GetCatalog(ctx context.Context, catalogName string) ApiGetCatalogRequest

	// GetCatalogExecute executes the request
	//  @return Catalog
	GetCatalogExecute(r ApiGetCatalogRequest) (*Catalog, *http.Response, error)

	/*
	GetCatalogRole Method for GetCatalogRole

	Get the details of an existing role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param catalogName The catalog for which we are retrieving roles
	@param catalogRoleName The name of the role
	@return ApiGetCatalogRoleRequest
	*/
	GetCatalogRole(ctx context.Context, catalogName string, catalogRoleName string) ApiGetCatalogRoleRequest

	// GetCatalogRoleExecute executes the request
	//  @return CatalogRole
	GetCatalogRoleExecute(r ApiGetCatalogRoleRequest) (*CatalogRole, *http.Response, error)

	/*
	GetPrincipal Method for GetPrincipal

	Get the principal details

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param principalName The principal name
	@return ApiGetPrincipalRequest
	*/
	GetPrincipal(ctx context.Context, principalName string) ApiGetPrincipalRequest

	// GetPrincipalExecute executes the request
	//  @return Principal
	GetPrincipalExecute(r ApiGetPrincipalRequest) (*Principal, *http.Response, error)

	/*
	GetPrincipalRole Method for GetPrincipalRole

	Get the principal role details

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param principalRoleName The principal role name
	@return ApiGetPrincipalRoleRequest
	*/
	GetPrincipalRole(ctx context.Context, principalRoleName string) ApiGetPrincipalRoleRequest

	// GetPrincipalRoleExecute executes the request
	//  @return PrincipalRole
	GetPrincipalRoleExecute(r ApiGetPrincipalRoleRequest) (*PrincipalRole, *http.Response, error)

	/*
	ListAssigneePrincipalRolesForCatalogRole Method for ListAssigneePrincipalRolesForCatalogRole

	List the PrincipalRoles to which the target catalog role has been assigned

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param catalogName The name of the catalog where the catalog role resides
	@param catalogRoleName The name of the catalog role
	@return ApiListAssigneePrincipalRolesForCatalogRoleRequest
	*/
	ListAssigneePrincipalRolesForCatalogRole(ctx context.Context, catalogName string, catalogRoleName string) ApiListAssigneePrincipalRolesForCatalogRoleRequest

	// ListAssigneePrincipalRolesForCatalogRoleExecute executes the request
	//  @return PrincipalRoles
	ListAssigneePrincipalRolesForCatalogRoleExecute(r ApiListAssigneePrincipalRolesForCatalogRoleRequest) (*PrincipalRoles, *http.Response, error)

	/*
	ListAssigneePrincipalsForPrincipalRole Method for ListAssigneePrincipalsForPrincipalRole

	List the Principals to whom the target principal role has been assigned

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param principalRoleName The principal role name
	@return ApiListAssigneePrincipalsForPrincipalRoleRequest
	*/
	ListAssigneePrincipalsForPrincipalRole(ctx context.Context, principalRoleName string) ApiListAssigneePrincipalsForPrincipalRoleRequest

	// ListAssigneePrincipalsForPrincipalRoleExecute executes the request
	//  @return Principals
	ListAssigneePrincipalsForPrincipalRoleExecute(r ApiListAssigneePrincipalsForPrincipalRoleRequest) (*Principals, *http.Response, error)

	/*
	ListCatalogRoles Method for ListCatalogRoles

	List existing roles in the catalog

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param catalogName The catalog for which we are reading/updating roles
	@return ApiListCatalogRolesRequest
	*/
	ListCatalogRoles(ctx context.Context, catalogName string) ApiListCatalogRolesRequest

	// ListCatalogRolesExecute executes the request
	//  @return CatalogRoles
	ListCatalogRolesExecute(r ApiListCatalogRolesRequest) (*CatalogRoles, *http.Response, error)

	/*
	ListCatalogRolesForPrincipalRole Method for ListCatalogRolesForPrincipalRole

	Get the catalog roles mapped to the principal role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param principalRoleName The principal role name
	@param catalogName The name of the catalog where the catalogRoles reside
	@return ApiListCatalogRolesForPrincipalRoleRequest
	*/
	ListCatalogRolesForPrincipalRole(ctx context.Context, principalRoleName string, catalogName string) ApiListCatalogRolesForPrincipalRoleRequest

	// ListCatalogRolesForPrincipalRoleExecute executes the request
	//  @return CatalogRoles
	ListCatalogRolesForPrincipalRoleExecute(r ApiListCatalogRolesForPrincipalRoleRequest) (*CatalogRoles, *http.Response, error)

	/*
	ListCatalogs Method for ListCatalogs

	List all catalogs in this polaris service

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListCatalogsRequest
	*/
	ListCatalogs(ctx context.Context) ApiListCatalogsRequest

	// ListCatalogsExecute executes the request
	//  @return Catalogs
	ListCatalogsExecute(r ApiListCatalogsRequest) (*Catalogs, *http.Response, error)

	/*
	ListGrantsForCatalogRole Method for ListGrantsForCatalogRole

	List the grants the catalog role holds

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param catalogName The name of the catalog where the role will receive the grant
	@param catalogRoleName The name of the role receiving the grant (must exist)
	@return ApiListGrantsForCatalogRoleRequest
	*/
	ListGrantsForCatalogRole(ctx context.Context, catalogName string, catalogRoleName string) ApiListGrantsForCatalogRoleRequest

	// ListGrantsForCatalogRoleExecute executes the request
	//  @return GrantResources
	ListGrantsForCatalogRoleExecute(r ApiListGrantsForCatalogRoleRequest) (*GrantResources, *http.Response, error)

	/*
	ListPrincipalRoles Method for ListPrincipalRoles

	List the principal roles

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListPrincipalRolesRequest
	*/
	ListPrincipalRoles(ctx context.Context) ApiListPrincipalRolesRequest

	// ListPrincipalRolesExecute executes the request
	//  @return PrincipalRoles
	ListPrincipalRolesExecute(r ApiListPrincipalRolesRequest) (*PrincipalRoles, *http.Response, error)

	/*
	ListPrincipalRolesAssigned Method for ListPrincipalRolesAssigned

	List the roles assigned to the principal

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param principalName The name of the target principal
	@return ApiListPrincipalRolesAssignedRequest
	*/
	ListPrincipalRolesAssigned(ctx context.Context, principalName string) ApiListPrincipalRolesAssignedRequest

	// ListPrincipalRolesAssignedExecute executes the request
	//  @return PrincipalRoles
	ListPrincipalRolesAssignedExecute(r ApiListPrincipalRolesAssignedRequest) (*PrincipalRoles, *http.Response, error)

	/*
	ListPrincipals Method for ListPrincipals

	List the principals for the current catalog

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListPrincipalsRequest
	*/
	ListPrincipals(ctx context.Context) ApiListPrincipalsRequest

	// ListPrincipalsExecute executes the request
	//  @return Principals
	ListPrincipalsExecute(r ApiListPrincipalsRequest) (*Principals, *http.Response, error)

	/*
	ResetCredentials Method for ResetCredentials

	Reset a principal's credentials to a new set. By default, the system generates random credentials unless explicitly allowed to accept user-provided credentials via configuration.   This API is *not* idempotent and will return the newly created credentials.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param principalName The principal's name
	@return ApiResetCredentialsRequest
	*/
	ResetCredentials(ctx context.Context, principalName string) ApiResetCredentialsRequest

	// ResetCredentialsExecute executes the request
	//  @return PrincipalWithCredentials
	ResetCredentialsExecute(r ApiResetCredentialsRequest) (*PrincipalWithCredentials, *http.Response, error)

	/*
	RevokeCatalogRoleFromPrincipalRole Method for RevokeCatalogRoleFromPrincipalRole

	Remove a catalog role from a principal role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param principalRoleName The principal role name
	@param catalogName The name of the catalog that contains the role to revoke
	@param catalogRoleName The name of the catalog role that should be revoked
	@return ApiRevokeCatalogRoleFromPrincipalRoleRequest
	*/
	RevokeCatalogRoleFromPrincipalRole(ctx context.Context, principalRoleName string, catalogName string, catalogRoleName string) ApiRevokeCatalogRoleFromPrincipalRoleRequest

	// RevokeCatalogRoleFromPrincipalRoleExecute executes the request
	RevokeCatalogRoleFromPrincipalRoleExecute(r ApiRevokeCatalogRoleFromPrincipalRoleRequest) (*http.Response, error)

	/*
	RevokeGrantFromCatalogRole Method for RevokeGrantFromCatalogRole

	Delete a specific grant from the role. This may be a subset or a superset of the grants the role has. In case of a subset, the role will retain the grants not specified. If the `cascade` parameter is true, grant revocation will have a cascading effect - that is, if a principal has specific grants on a subresource, and grants are revoked on a parent resource, the grants present on the subresource will be revoked as well. By default, this behavior is disabled and grant revocation only affects the specified resource.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param catalogName The name of the catalog where the role will receive the grant
	@param catalogRoleName The name of the role receiving the grant (must exist)
	@return ApiRevokeGrantFromCatalogRoleRequest
	*/
	RevokeGrantFromCatalogRole(ctx context.Context, catalogName string, catalogRoleName string) ApiRevokeGrantFromCatalogRoleRequest

	// RevokeGrantFromCatalogRoleExecute executes the request
	RevokeGrantFromCatalogRoleExecute(r ApiRevokeGrantFromCatalogRoleRequest) (*http.Response, error)

	/*
	RevokePrincipalRole Method for RevokePrincipalRole

	Remove a role from a catalog principal

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param principalName The name of the target principal
	@param principalRoleName The name of the role
	@return ApiRevokePrincipalRoleRequest
	*/
	RevokePrincipalRole(ctx context.Context, principalName string, principalRoleName string) ApiRevokePrincipalRoleRequest

	// RevokePrincipalRoleExecute executes the request
	RevokePrincipalRoleExecute(r ApiRevokePrincipalRoleRequest) (*http.Response, error)

	/*
	RotateCredentials Method for RotateCredentials

	Rotate a principal's credentials. The new credentials will be returned in the response. This is the only API, aside from createPrincipal, that returns the user's credentials. This API is *not* idempotent.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param principalName The user name
	@return ApiRotateCredentialsRequest
	*/
	RotateCredentials(ctx context.Context, principalName string) ApiRotateCredentialsRequest

	// RotateCredentialsExecute executes the request
	//  @return PrincipalWithCredentials
	RotateCredentialsExecute(r ApiRotateCredentialsRequest) (*PrincipalWithCredentials, *http.Response, error)

	/*
	UpdateCatalog Method for UpdateCatalog

	Update an existing catalog

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param catalogName The name of the catalog
	@return ApiUpdateCatalogRequest
	*/
	UpdateCatalog(ctx context.Context, catalogName string) ApiUpdateCatalogRequest

	// UpdateCatalogExecute executes the request
	//  @return Catalog
	UpdateCatalogExecute(r ApiUpdateCatalogRequest) (*Catalog, *http.Response, error)

	/*
	UpdateCatalogRole Method for UpdateCatalogRole

	Update an existing role in the catalog

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param catalogName The catalog for which we are retrieving roles
	@param catalogRoleName The name of the role
	@return ApiUpdateCatalogRoleRequest
	*/
	UpdateCatalogRole(ctx context.Context, catalogName string, catalogRoleName string) ApiUpdateCatalogRoleRequest

	// UpdateCatalogRoleExecute executes the request
	//  @return CatalogRole
	UpdateCatalogRoleExecute(r ApiUpdateCatalogRoleRequest) (*CatalogRole, *http.Response, error)

	/*
	UpdatePrincipal Method for UpdatePrincipal

	Update an existing principal

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param principalName The principal name
	@return ApiUpdatePrincipalRequest
	*/
	UpdatePrincipal(ctx context.Context, principalName string) ApiUpdatePrincipalRequest

	// UpdatePrincipalExecute executes the request
	//  @return Principal
	UpdatePrincipalExecute(r ApiUpdatePrincipalRequest) (*Principal, *http.Response, error)

	/*
	UpdatePrincipalRole Method for UpdatePrincipalRole

	Update an existing principalRole

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param principalRoleName The principal role name
	@return ApiUpdatePrincipalRoleRequest
	*/
	UpdatePrincipalRole(ctx context.Context, principalRoleName string) ApiUpdatePrincipalRoleRequest

	// UpdatePrincipalRoleExecute executes the request
	//  @return PrincipalRole
	UpdatePrincipalRoleExecute(r ApiUpdatePrincipalRoleRequest) (*PrincipalRole, *http.Response, error)
}

// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type ApiAddGrantToCatalogRoleRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	catalogName string
	catalogRoleName string
	addGrantRequest *AddGrantRequest
}

func (r ApiAddGrantToCatalogRoleRequest) AddGrantRequest(addGrantRequest AddGrantRequest) ApiAddGrantToCatalogRoleRequest {
	r.addGrantRequest = &addGrantRequest
	return r
}

func (r ApiAddGrantToCatalogRoleRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddGrantToCatalogRoleExecute(r)
}

/*
AddGrantToCatalogRole Method for AddGrantToCatalogRole

Add a new grant to the catalog role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catalogName The name of the catalog where the role will receive the grant
 @param catalogRoleName The name of the role receiving the grant (must exist)
 @return ApiAddGrantToCatalogRoleRequest
*/
func (a *DefaultAPIService) AddGrantToCatalogRole(ctx context.Context, catalogName string, catalogRoleName string) ApiAddGrantToCatalogRoleRequest {
	return ApiAddGrantToCatalogRoleRequest{
		ApiService: a,
		ctx: ctx,
		catalogName: catalogName,
		catalogRoleName: catalogRoleName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) AddGrantToCatalogRoleExecute(r ApiAddGrantToCatalogRoleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.AddGrantToCatalogRole")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalogs/{catalogName}/catalog-roles/{catalogRoleName}/grants"
	localVarPath = strings.Replace(localVarPath, "{"+"catalogName"+"}", url.PathEscape(parameterValueToString(r.catalogName, "catalogName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"catalogRoleName"+"}", url.PathEscape(parameterValueToString(r.catalogRoleName, "catalogRoleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.catalogName) < 1 {
		return nil, reportError("catalogName must have at least 1 elements")
	}
	if strlen(r.catalogName) > 256 {
		return nil, reportError("catalogName must have less than 256 elements")
	}
	if strlen(r.catalogRoleName) < 1 {
		return nil, reportError("catalogRoleName must have at least 1 elements")
	}
	if strlen(r.catalogRoleName) > 256 {
		return nil, reportError("catalogRoleName must have less than 256 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addGrantRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAssignCatalogRoleToPrincipalRoleRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	principalRoleName string
	catalogName string
	grantCatalogRoleRequest *GrantCatalogRoleRequest
}

// The principal to create
func (r ApiAssignCatalogRoleToPrincipalRoleRequest) GrantCatalogRoleRequest(grantCatalogRoleRequest GrantCatalogRoleRequest) ApiAssignCatalogRoleToPrincipalRoleRequest {
	r.grantCatalogRoleRequest = &grantCatalogRoleRequest
	return r
}

func (r ApiAssignCatalogRoleToPrincipalRoleRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssignCatalogRoleToPrincipalRoleExecute(r)
}

/*
AssignCatalogRoleToPrincipalRole Method for AssignCatalogRoleToPrincipalRole

Assign a catalog role to a principal role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param principalRoleName The principal role name
 @param catalogName The name of the catalog where the catalogRoles reside
 @return ApiAssignCatalogRoleToPrincipalRoleRequest
*/
func (a *DefaultAPIService) AssignCatalogRoleToPrincipalRole(ctx context.Context, principalRoleName string, catalogName string) ApiAssignCatalogRoleToPrincipalRoleRequest {
	return ApiAssignCatalogRoleToPrincipalRoleRequest{
		ApiService: a,
		ctx: ctx,
		principalRoleName: principalRoleName,
		catalogName: catalogName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) AssignCatalogRoleToPrincipalRoleExecute(r ApiAssignCatalogRoleToPrincipalRoleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.AssignCatalogRoleToPrincipalRole")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/principal-roles/{principalRoleName}/catalog-roles/{catalogName}"
	localVarPath = strings.Replace(localVarPath, "{"+"principalRoleName"+"}", url.PathEscape(parameterValueToString(r.principalRoleName, "principalRoleName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"catalogName"+"}", url.PathEscape(parameterValueToString(r.catalogName, "catalogName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.principalRoleName) < 1 {
		return nil, reportError("principalRoleName must have at least 1 elements")
	}
	if strlen(r.principalRoleName) > 256 {
		return nil, reportError("principalRoleName must have less than 256 elements")
	}
	if strlen(r.catalogName) < 1 {
		return nil, reportError("catalogName must have at least 1 elements")
	}
	if strlen(r.catalogName) > 256 {
		return nil, reportError("catalogName must have less than 256 elements")
	}
	if r.grantCatalogRoleRequest == nil {
		return nil, reportError("grantCatalogRoleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.grantCatalogRoleRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAssignPrincipalRoleRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	principalName string
	grantPrincipalRoleRequest *GrantPrincipalRoleRequest
}

// The principal role to assign
func (r ApiAssignPrincipalRoleRequest) GrantPrincipalRoleRequest(grantPrincipalRoleRequest GrantPrincipalRoleRequest) ApiAssignPrincipalRoleRequest {
	r.grantPrincipalRoleRequest = &grantPrincipalRoleRequest
	return r
}

func (r ApiAssignPrincipalRoleRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssignPrincipalRoleExecute(r)
}

/*
AssignPrincipalRole Method for AssignPrincipalRole

Add a role to the principal

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param principalName The name of the target principal
 @return ApiAssignPrincipalRoleRequest
*/
func (a *DefaultAPIService) AssignPrincipalRole(ctx context.Context, principalName string) ApiAssignPrincipalRoleRequest {
	return ApiAssignPrincipalRoleRequest{
		ApiService: a,
		ctx: ctx,
		principalName: principalName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) AssignPrincipalRoleExecute(r ApiAssignPrincipalRoleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.AssignPrincipalRole")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/principals/{principalName}/principal-roles"
	localVarPath = strings.Replace(localVarPath, "{"+"principalName"+"}", url.PathEscape(parameterValueToString(r.principalName, "principalName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.principalName) < 1 {
		return nil, reportError("principalName must have at least 1 elements")
	}
	if strlen(r.principalName) > 256 {
		return nil, reportError("principalName must have less than 256 elements")
	}
	if r.grantPrincipalRoleRequest == nil {
		return nil, reportError("grantPrincipalRoleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.grantPrincipalRoleRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateCatalogRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	createCatalogRequest *CreateCatalogRequest
}

// The Catalog to create
func (r ApiCreateCatalogRequest) CreateCatalogRequest(createCatalogRequest CreateCatalogRequest) ApiCreateCatalogRequest {
	r.createCatalogRequest = &createCatalogRequest
	return r
}

func (r ApiCreateCatalogRequest) Execute() (*Catalog, *http.Response, error) {
	return r.ApiService.CreateCatalogExecute(r)
}

/*
CreateCatalog Method for CreateCatalog

Add a new Catalog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCatalogRequest
*/
func (a *DefaultAPIService) CreateCatalog(ctx context.Context) ApiCreateCatalogRequest {
	return ApiCreateCatalogRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Catalog
func (a *DefaultAPIService) CreateCatalogExecute(r ApiCreateCatalogRequest) (*Catalog, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Catalog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreateCatalog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalogs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createCatalogRequest == nil {
		return localVarReturnValue, nil, reportError("createCatalogRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createCatalogRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCatalogRoleRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	catalogName string
	createCatalogRoleRequest *CreateCatalogRoleRequest
}

func (r ApiCreateCatalogRoleRequest) CreateCatalogRoleRequest(createCatalogRoleRequest CreateCatalogRoleRequest) ApiCreateCatalogRoleRequest {
	r.createCatalogRoleRequest = &createCatalogRoleRequest
	return r
}

func (r ApiCreateCatalogRoleRequest) Execute() (*CatalogRole, *http.Response, error) {
	return r.ApiService.CreateCatalogRoleExecute(r)
}

/*
CreateCatalogRole Method for CreateCatalogRole

Create a new role in the catalog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catalogName The catalog for which we are reading/updating roles
 @return ApiCreateCatalogRoleRequest
*/
func (a *DefaultAPIService) CreateCatalogRole(ctx context.Context, catalogName string) ApiCreateCatalogRoleRequest {
	return ApiCreateCatalogRoleRequest{
		ApiService: a,
		ctx: ctx,
		catalogName: catalogName,
	}
}

// Execute executes the request
//  @return CatalogRole
func (a *DefaultAPIService) CreateCatalogRoleExecute(r ApiCreateCatalogRoleRequest) (*CatalogRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CatalogRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreateCatalogRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalogs/{catalogName}/catalog-roles"
	localVarPath = strings.Replace(localVarPath, "{"+"catalogName"+"}", url.PathEscape(parameterValueToString(r.catalogName, "catalogName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.catalogName) < 1 {
		return localVarReturnValue, nil, reportError("catalogName must have at least 1 elements")
	}
	if strlen(r.catalogName) > 256 {
		return localVarReturnValue, nil, reportError("catalogName must have less than 256 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createCatalogRoleRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePrincipalRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	createPrincipalRequest *CreatePrincipalRequest
}

// The principal to create
func (r ApiCreatePrincipalRequest) CreatePrincipalRequest(createPrincipalRequest CreatePrincipalRequest) ApiCreatePrincipalRequest {
	r.createPrincipalRequest = &createPrincipalRequest
	return r
}

func (r ApiCreatePrincipalRequest) Execute() (*PrincipalWithCredentials, *http.Response, error) {
	return r.ApiService.CreatePrincipalExecute(r)
}

/*
CreatePrincipal Method for CreatePrincipal

Create a principal

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreatePrincipalRequest
*/
func (a *DefaultAPIService) CreatePrincipal(ctx context.Context) ApiCreatePrincipalRequest {
	return ApiCreatePrincipalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PrincipalWithCredentials
func (a *DefaultAPIService) CreatePrincipalExecute(r ApiCreatePrincipalRequest) (*PrincipalWithCredentials, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PrincipalWithCredentials
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreatePrincipal")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/principals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createPrincipalRequest == nil {
		return localVarReturnValue, nil, reportError("createPrincipalRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createPrincipalRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePrincipalRoleRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	createPrincipalRoleRequest *CreatePrincipalRoleRequest
}

// The principal to create
func (r ApiCreatePrincipalRoleRequest) CreatePrincipalRoleRequest(createPrincipalRoleRequest CreatePrincipalRoleRequest) ApiCreatePrincipalRoleRequest {
	r.createPrincipalRoleRequest = &createPrincipalRoleRequest
	return r
}

func (r ApiCreatePrincipalRoleRequest) Execute() (*PrincipalRole, *http.Response, error) {
	return r.ApiService.CreatePrincipalRoleExecute(r)
}

/*
CreatePrincipalRole Method for CreatePrincipalRole

Create a principal role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreatePrincipalRoleRequest
*/
func (a *DefaultAPIService) CreatePrincipalRole(ctx context.Context) ApiCreatePrincipalRoleRequest {
	return ApiCreatePrincipalRoleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PrincipalRole
func (a *DefaultAPIService) CreatePrincipalRoleExecute(r ApiCreatePrincipalRoleRequest) (*PrincipalRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PrincipalRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreatePrincipalRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/principal-roles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createPrincipalRoleRequest == nil {
		return localVarReturnValue, nil, reportError("createPrincipalRoleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createPrincipalRoleRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCatalogRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	catalogName string
}

func (r ApiDeleteCatalogRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCatalogExecute(r)
}

/*
DeleteCatalog Method for DeleteCatalog

Delete an existing catalog. The catalog must be empty.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catalogName The name of the catalog
 @return ApiDeleteCatalogRequest
*/
func (a *DefaultAPIService) DeleteCatalog(ctx context.Context, catalogName string) ApiDeleteCatalogRequest {
	return ApiDeleteCatalogRequest{
		ApiService: a,
		ctx: ctx,
		catalogName: catalogName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) DeleteCatalogExecute(r ApiDeleteCatalogRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteCatalog")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalogs/{catalogName}"
	localVarPath = strings.Replace(localVarPath, "{"+"catalogName"+"}", url.PathEscape(parameterValueToString(r.catalogName, "catalogName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.catalogName) < 1 {
		return nil, reportError("catalogName must have at least 1 elements")
	}
	if strlen(r.catalogName) > 256 {
		return nil, reportError("catalogName must have less than 256 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteCatalogRoleRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	catalogName string
	catalogRoleName string
}

func (r ApiDeleteCatalogRoleRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCatalogRoleExecute(r)
}

/*
DeleteCatalogRole Method for DeleteCatalogRole

Delete an existing role from the catalog. All associated grants will also be deleted

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catalogName The catalog for which we are retrieving roles
 @param catalogRoleName The name of the role
 @return ApiDeleteCatalogRoleRequest
*/
func (a *DefaultAPIService) DeleteCatalogRole(ctx context.Context, catalogName string, catalogRoleName string) ApiDeleteCatalogRoleRequest {
	return ApiDeleteCatalogRoleRequest{
		ApiService: a,
		ctx: ctx,
		catalogName: catalogName,
		catalogRoleName: catalogRoleName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) DeleteCatalogRoleExecute(r ApiDeleteCatalogRoleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteCatalogRole")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalogs/{catalogName}/catalog-roles/{catalogRoleName}"
	localVarPath = strings.Replace(localVarPath, "{"+"catalogName"+"}", url.PathEscape(parameterValueToString(r.catalogName, "catalogName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"catalogRoleName"+"}", url.PathEscape(parameterValueToString(r.catalogRoleName, "catalogRoleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.catalogName) < 1 {
		return nil, reportError("catalogName must have at least 1 elements")
	}
	if strlen(r.catalogName) > 256 {
		return nil, reportError("catalogName must have less than 256 elements")
	}
	if strlen(r.catalogRoleName) < 1 {
		return nil, reportError("catalogRoleName must have at least 1 elements")
	}
	if strlen(r.catalogRoleName) > 256 {
		return nil, reportError("catalogRoleName must have less than 256 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeletePrincipalRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	principalName string
}

func (r ApiDeletePrincipalRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePrincipalExecute(r)
}

/*
DeletePrincipal Method for DeletePrincipal

Remove a principal from polaris

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param principalName The principal name
 @return ApiDeletePrincipalRequest
*/
func (a *DefaultAPIService) DeletePrincipal(ctx context.Context, principalName string) ApiDeletePrincipalRequest {
	return ApiDeletePrincipalRequest{
		ApiService: a,
		ctx: ctx,
		principalName: principalName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) DeletePrincipalExecute(r ApiDeletePrincipalRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeletePrincipal")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/principals/{principalName}"
	localVarPath = strings.Replace(localVarPath, "{"+"principalName"+"}", url.PathEscape(parameterValueToString(r.principalName, "principalName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.principalName) < 1 {
		return nil, reportError("principalName must have at least 1 elements")
	}
	if strlen(r.principalName) > 256 {
		return nil, reportError("principalName must have less than 256 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeletePrincipalRoleRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	principalRoleName string
}

func (r ApiDeletePrincipalRoleRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePrincipalRoleExecute(r)
}

/*
DeletePrincipalRole Method for DeletePrincipalRole

Remove a principal role from polaris

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param principalRoleName The principal role name
 @return ApiDeletePrincipalRoleRequest
*/
func (a *DefaultAPIService) DeletePrincipalRole(ctx context.Context, principalRoleName string) ApiDeletePrincipalRoleRequest {
	return ApiDeletePrincipalRoleRequest{
		ApiService: a,
		ctx: ctx,
		principalRoleName: principalRoleName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) DeletePrincipalRoleExecute(r ApiDeletePrincipalRoleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeletePrincipalRole")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/principal-roles/{principalRoleName}"
	localVarPath = strings.Replace(localVarPath, "{"+"principalRoleName"+"}", url.PathEscape(parameterValueToString(r.principalRoleName, "principalRoleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.principalRoleName) < 1 {
		return nil, reportError("principalRoleName must have at least 1 elements")
	}
	if strlen(r.principalRoleName) > 256 {
		return nil, reportError("principalRoleName must have less than 256 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetCatalogRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	catalogName string
}

func (r ApiGetCatalogRequest) Execute() (*Catalog, *http.Response, error) {
	return r.ApiService.GetCatalogExecute(r)
}

/*
GetCatalog Method for GetCatalog

Get the details of a catalog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catalogName The name of the catalog
 @return ApiGetCatalogRequest
*/
func (a *DefaultAPIService) GetCatalog(ctx context.Context, catalogName string) ApiGetCatalogRequest {
	return ApiGetCatalogRequest{
		ApiService: a,
		ctx: ctx,
		catalogName: catalogName,
	}
}

// Execute executes the request
//  @return Catalog
func (a *DefaultAPIService) GetCatalogExecute(r ApiGetCatalogRequest) (*Catalog, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Catalog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetCatalog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalogs/{catalogName}"
	localVarPath = strings.Replace(localVarPath, "{"+"catalogName"+"}", url.PathEscape(parameterValueToString(r.catalogName, "catalogName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.catalogName) < 1 {
		return localVarReturnValue, nil, reportError("catalogName must have at least 1 elements")
	}
	if strlen(r.catalogName) > 256 {
		return localVarReturnValue, nil, reportError("catalogName must have less than 256 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCatalogRoleRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	catalogName string
	catalogRoleName string
}

func (r ApiGetCatalogRoleRequest) Execute() (*CatalogRole, *http.Response, error) {
	return r.ApiService.GetCatalogRoleExecute(r)
}

/*
GetCatalogRole Method for GetCatalogRole

Get the details of an existing role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catalogName The catalog for which we are retrieving roles
 @param catalogRoleName The name of the role
 @return ApiGetCatalogRoleRequest
*/
func (a *DefaultAPIService) GetCatalogRole(ctx context.Context, catalogName string, catalogRoleName string) ApiGetCatalogRoleRequest {
	return ApiGetCatalogRoleRequest{
		ApiService: a,
		ctx: ctx,
		catalogName: catalogName,
		catalogRoleName: catalogRoleName,
	}
}

// Execute executes the request
//  @return CatalogRole
func (a *DefaultAPIService) GetCatalogRoleExecute(r ApiGetCatalogRoleRequest) (*CatalogRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CatalogRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetCatalogRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalogs/{catalogName}/catalog-roles/{catalogRoleName}"
	localVarPath = strings.Replace(localVarPath, "{"+"catalogName"+"}", url.PathEscape(parameterValueToString(r.catalogName, "catalogName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"catalogRoleName"+"}", url.PathEscape(parameterValueToString(r.catalogRoleName, "catalogRoleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.catalogName) < 1 {
		return localVarReturnValue, nil, reportError("catalogName must have at least 1 elements")
	}
	if strlen(r.catalogName) > 256 {
		return localVarReturnValue, nil, reportError("catalogName must have less than 256 elements")
	}
	if strlen(r.catalogRoleName) < 1 {
		return localVarReturnValue, nil, reportError("catalogRoleName must have at least 1 elements")
	}
	if strlen(r.catalogRoleName) > 256 {
		return localVarReturnValue, nil, reportError("catalogRoleName must have less than 256 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPrincipalRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	principalName string
}

func (r ApiGetPrincipalRequest) Execute() (*Principal, *http.Response, error) {
	return r.ApiService.GetPrincipalExecute(r)
}

/*
GetPrincipal Method for GetPrincipal

Get the principal details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param principalName The principal name
 @return ApiGetPrincipalRequest
*/
func (a *DefaultAPIService) GetPrincipal(ctx context.Context, principalName string) ApiGetPrincipalRequest {
	return ApiGetPrincipalRequest{
		ApiService: a,
		ctx: ctx,
		principalName: principalName,
	}
}

// Execute executes the request
//  @return Principal
func (a *DefaultAPIService) GetPrincipalExecute(r ApiGetPrincipalRequest) (*Principal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Principal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetPrincipal")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/principals/{principalName}"
	localVarPath = strings.Replace(localVarPath, "{"+"principalName"+"}", url.PathEscape(parameterValueToString(r.principalName, "principalName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.principalName) < 1 {
		return localVarReturnValue, nil, reportError("principalName must have at least 1 elements")
	}
	if strlen(r.principalName) > 256 {
		return localVarReturnValue, nil, reportError("principalName must have less than 256 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPrincipalRoleRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	principalRoleName string
}

func (r ApiGetPrincipalRoleRequest) Execute() (*PrincipalRole, *http.Response, error) {
	return r.ApiService.GetPrincipalRoleExecute(r)
}

/*
GetPrincipalRole Method for GetPrincipalRole

Get the principal role details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param principalRoleName The principal role name
 @return ApiGetPrincipalRoleRequest
*/
func (a *DefaultAPIService) GetPrincipalRole(ctx context.Context, principalRoleName string) ApiGetPrincipalRoleRequest {
	return ApiGetPrincipalRoleRequest{
		ApiService: a,
		ctx: ctx,
		principalRoleName: principalRoleName,
	}
}

// Execute executes the request
//  @return PrincipalRole
func (a *DefaultAPIService) GetPrincipalRoleExecute(r ApiGetPrincipalRoleRequest) (*PrincipalRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PrincipalRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetPrincipalRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/principal-roles/{principalRoleName}"
	localVarPath = strings.Replace(localVarPath, "{"+"principalRoleName"+"}", url.PathEscape(parameterValueToString(r.principalRoleName, "principalRoleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.principalRoleName) < 1 {
		return localVarReturnValue, nil, reportError("principalRoleName must have at least 1 elements")
	}
	if strlen(r.principalRoleName) > 256 {
		return localVarReturnValue, nil, reportError("principalRoleName must have less than 256 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAssigneePrincipalRolesForCatalogRoleRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	catalogName string
	catalogRoleName string
}

func (r ApiListAssigneePrincipalRolesForCatalogRoleRequest) Execute() (*PrincipalRoles, *http.Response, error) {
	return r.ApiService.ListAssigneePrincipalRolesForCatalogRoleExecute(r)
}

/*
ListAssigneePrincipalRolesForCatalogRole Method for ListAssigneePrincipalRolesForCatalogRole

List the PrincipalRoles to which the target catalog role has been assigned

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catalogName The name of the catalog where the catalog role resides
 @param catalogRoleName The name of the catalog role
 @return ApiListAssigneePrincipalRolesForCatalogRoleRequest
*/
func (a *DefaultAPIService) ListAssigneePrincipalRolesForCatalogRole(ctx context.Context, catalogName string, catalogRoleName string) ApiListAssigneePrincipalRolesForCatalogRoleRequest {
	return ApiListAssigneePrincipalRolesForCatalogRoleRequest{
		ApiService: a,
		ctx: ctx,
		catalogName: catalogName,
		catalogRoleName: catalogRoleName,
	}
}

// Execute executes the request
//  @return PrincipalRoles
func (a *DefaultAPIService) ListAssigneePrincipalRolesForCatalogRoleExecute(r ApiListAssigneePrincipalRolesForCatalogRoleRequest) (*PrincipalRoles, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PrincipalRoles
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ListAssigneePrincipalRolesForCatalogRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalogs/{catalogName}/catalog-roles/{catalogRoleName}/principal-roles"
	localVarPath = strings.Replace(localVarPath, "{"+"catalogName"+"}", url.PathEscape(parameterValueToString(r.catalogName, "catalogName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"catalogRoleName"+"}", url.PathEscape(parameterValueToString(r.catalogRoleName, "catalogRoleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.catalogName) < 1 {
		return localVarReturnValue, nil, reportError("catalogName must have at least 1 elements")
	}
	if strlen(r.catalogName) > 256 {
		return localVarReturnValue, nil, reportError("catalogName must have less than 256 elements")
	}
	if strlen(r.catalogRoleName) < 1 {
		return localVarReturnValue, nil, reportError("catalogRoleName must have at least 1 elements")
	}
	if strlen(r.catalogRoleName) > 256 {
		return localVarReturnValue, nil, reportError("catalogRoleName must have less than 256 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAssigneePrincipalsForPrincipalRoleRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	principalRoleName string
}

func (r ApiListAssigneePrincipalsForPrincipalRoleRequest) Execute() (*Principals, *http.Response, error) {
	return r.ApiService.ListAssigneePrincipalsForPrincipalRoleExecute(r)
}

/*
ListAssigneePrincipalsForPrincipalRole Method for ListAssigneePrincipalsForPrincipalRole

List the Principals to whom the target principal role has been assigned

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param principalRoleName The principal role name
 @return ApiListAssigneePrincipalsForPrincipalRoleRequest
*/
func (a *DefaultAPIService) ListAssigneePrincipalsForPrincipalRole(ctx context.Context, principalRoleName string) ApiListAssigneePrincipalsForPrincipalRoleRequest {
	return ApiListAssigneePrincipalsForPrincipalRoleRequest{
		ApiService: a,
		ctx: ctx,
		principalRoleName: principalRoleName,
	}
}

// Execute executes the request
//  @return Principals
func (a *DefaultAPIService) ListAssigneePrincipalsForPrincipalRoleExecute(r ApiListAssigneePrincipalsForPrincipalRoleRequest) (*Principals, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Principals
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ListAssigneePrincipalsForPrincipalRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/principal-roles/{principalRoleName}/principals"
	localVarPath = strings.Replace(localVarPath, "{"+"principalRoleName"+"}", url.PathEscape(parameterValueToString(r.principalRoleName, "principalRoleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.principalRoleName) < 1 {
		return localVarReturnValue, nil, reportError("principalRoleName must have at least 1 elements")
	}
	if strlen(r.principalRoleName) > 256 {
		return localVarReturnValue, nil, reportError("principalRoleName must have less than 256 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCatalogRolesRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	catalogName string
}

func (r ApiListCatalogRolesRequest) Execute() (*CatalogRoles, *http.Response, error) {
	return r.ApiService.ListCatalogRolesExecute(r)
}

/*
ListCatalogRoles Method for ListCatalogRoles

List existing roles in the catalog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catalogName The catalog for which we are reading/updating roles
 @return ApiListCatalogRolesRequest
*/
func (a *DefaultAPIService) ListCatalogRoles(ctx context.Context, catalogName string) ApiListCatalogRolesRequest {
	return ApiListCatalogRolesRequest{
		ApiService: a,
		ctx: ctx,
		catalogName: catalogName,
	}
}

// Execute executes the request
//  @return CatalogRoles
func (a *DefaultAPIService) ListCatalogRolesExecute(r ApiListCatalogRolesRequest) (*CatalogRoles, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CatalogRoles
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ListCatalogRoles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalogs/{catalogName}/catalog-roles"
	localVarPath = strings.Replace(localVarPath, "{"+"catalogName"+"}", url.PathEscape(parameterValueToString(r.catalogName, "catalogName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.catalogName) < 1 {
		return localVarReturnValue, nil, reportError("catalogName must have at least 1 elements")
	}
	if strlen(r.catalogName) > 256 {
		return localVarReturnValue, nil, reportError("catalogName must have less than 256 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCatalogRolesForPrincipalRoleRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	principalRoleName string
	catalogName string
}

func (r ApiListCatalogRolesForPrincipalRoleRequest) Execute() (*CatalogRoles, *http.Response, error) {
	return r.ApiService.ListCatalogRolesForPrincipalRoleExecute(r)
}

/*
ListCatalogRolesForPrincipalRole Method for ListCatalogRolesForPrincipalRole

Get the catalog roles mapped to the principal role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param principalRoleName The principal role name
 @param catalogName The name of the catalog where the catalogRoles reside
 @return ApiListCatalogRolesForPrincipalRoleRequest
*/
func (a *DefaultAPIService) ListCatalogRolesForPrincipalRole(ctx context.Context, principalRoleName string, catalogName string) ApiListCatalogRolesForPrincipalRoleRequest {
	return ApiListCatalogRolesForPrincipalRoleRequest{
		ApiService: a,
		ctx: ctx,
		principalRoleName: principalRoleName,
		catalogName: catalogName,
	}
}

// Execute executes the request
//  @return CatalogRoles
func (a *DefaultAPIService) ListCatalogRolesForPrincipalRoleExecute(r ApiListCatalogRolesForPrincipalRoleRequest) (*CatalogRoles, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CatalogRoles
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ListCatalogRolesForPrincipalRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/principal-roles/{principalRoleName}/catalog-roles/{catalogName}"
	localVarPath = strings.Replace(localVarPath, "{"+"principalRoleName"+"}", url.PathEscape(parameterValueToString(r.principalRoleName, "principalRoleName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"catalogName"+"}", url.PathEscape(parameterValueToString(r.catalogName, "catalogName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.principalRoleName) < 1 {
		return localVarReturnValue, nil, reportError("principalRoleName must have at least 1 elements")
	}
	if strlen(r.principalRoleName) > 256 {
		return localVarReturnValue, nil, reportError("principalRoleName must have less than 256 elements")
	}
	if strlen(r.catalogName) < 1 {
		return localVarReturnValue, nil, reportError("catalogName must have at least 1 elements")
	}
	if strlen(r.catalogName) > 256 {
		return localVarReturnValue, nil, reportError("catalogName must have less than 256 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCatalogsRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiListCatalogsRequest) Execute() (*Catalogs, *http.Response, error) {
	return r.ApiService.ListCatalogsExecute(r)
}

/*
ListCatalogs Method for ListCatalogs

List all catalogs in this polaris service

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListCatalogsRequest
*/
func (a *DefaultAPIService) ListCatalogs(ctx context.Context) ApiListCatalogsRequest {
	return ApiListCatalogsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Catalogs
func (a *DefaultAPIService) ListCatalogsExecute(r ApiListCatalogsRequest) (*Catalogs, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Catalogs
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ListCatalogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalogs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListGrantsForCatalogRoleRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	catalogName string
	catalogRoleName string
}

func (r ApiListGrantsForCatalogRoleRequest) Execute() (*GrantResources, *http.Response, error) {
	return r.ApiService.ListGrantsForCatalogRoleExecute(r)
}

/*
ListGrantsForCatalogRole Method for ListGrantsForCatalogRole

List the grants the catalog role holds

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catalogName The name of the catalog where the role will receive the grant
 @param catalogRoleName The name of the role receiving the grant (must exist)
 @return ApiListGrantsForCatalogRoleRequest
*/
func (a *DefaultAPIService) ListGrantsForCatalogRole(ctx context.Context, catalogName string, catalogRoleName string) ApiListGrantsForCatalogRoleRequest {
	return ApiListGrantsForCatalogRoleRequest{
		ApiService: a,
		ctx: ctx,
		catalogName: catalogName,
		catalogRoleName: catalogRoleName,
	}
}

// Execute executes the request
//  @return GrantResources
func (a *DefaultAPIService) ListGrantsForCatalogRoleExecute(r ApiListGrantsForCatalogRoleRequest) (*GrantResources, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GrantResources
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ListGrantsForCatalogRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalogs/{catalogName}/catalog-roles/{catalogRoleName}/grants"
	localVarPath = strings.Replace(localVarPath, "{"+"catalogName"+"}", url.PathEscape(parameterValueToString(r.catalogName, "catalogName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"catalogRoleName"+"}", url.PathEscape(parameterValueToString(r.catalogRoleName, "catalogRoleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.catalogName) < 1 {
		return localVarReturnValue, nil, reportError("catalogName must have at least 1 elements")
	}
	if strlen(r.catalogName) > 256 {
		return localVarReturnValue, nil, reportError("catalogName must have less than 256 elements")
	}
	if strlen(r.catalogRoleName) < 1 {
		return localVarReturnValue, nil, reportError("catalogRoleName must have at least 1 elements")
	}
	if strlen(r.catalogRoleName) > 256 {
		return localVarReturnValue, nil, reportError("catalogRoleName must have less than 256 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPrincipalRolesRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiListPrincipalRolesRequest) Execute() (*PrincipalRoles, *http.Response, error) {
	return r.ApiService.ListPrincipalRolesExecute(r)
}

/*
ListPrincipalRoles Method for ListPrincipalRoles

List the principal roles

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListPrincipalRolesRequest
*/
func (a *DefaultAPIService) ListPrincipalRoles(ctx context.Context) ApiListPrincipalRolesRequest {
	return ApiListPrincipalRolesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PrincipalRoles
func (a *DefaultAPIService) ListPrincipalRolesExecute(r ApiListPrincipalRolesRequest) (*PrincipalRoles, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PrincipalRoles
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ListPrincipalRoles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/principal-roles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPrincipalRolesAssignedRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	principalName string
}

func (r ApiListPrincipalRolesAssignedRequest) Execute() (*PrincipalRoles, *http.Response, error) {
	return r.ApiService.ListPrincipalRolesAssignedExecute(r)
}

/*
ListPrincipalRolesAssigned Method for ListPrincipalRolesAssigned

List the roles assigned to the principal

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param principalName The name of the target principal
 @return ApiListPrincipalRolesAssignedRequest
*/
func (a *DefaultAPIService) ListPrincipalRolesAssigned(ctx context.Context, principalName string) ApiListPrincipalRolesAssignedRequest {
	return ApiListPrincipalRolesAssignedRequest{
		ApiService: a,
		ctx: ctx,
		principalName: principalName,
	}
}

// Execute executes the request
//  @return PrincipalRoles
func (a *DefaultAPIService) ListPrincipalRolesAssignedExecute(r ApiListPrincipalRolesAssignedRequest) (*PrincipalRoles, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PrincipalRoles
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ListPrincipalRolesAssigned")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/principals/{principalName}/principal-roles"
	localVarPath = strings.Replace(localVarPath, "{"+"principalName"+"}", url.PathEscape(parameterValueToString(r.principalName, "principalName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.principalName) < 1 {
		return localVarReturnValue, nil, reportError("principalName must have at least 1 elements")
	}
	if strlen(r.principalName) > 256 {
		return localVarReturnValue, nil, reportError("principalName must have less than 256 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPrincipalsRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiListPrincipalsRequest) Execute() (*Principals, *http.Response, error) {
	return r.ApiService.ListPrincipalsExecute(r)
}

/*
ListPrincipals Method for ListPrincipals

List the principals for the current catalog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListPrincipalsRequest
*/
func (a *DefaultAPIService) ListPrincipals(ctx context.Context) ApiListPrincipalsRequest {
	return ApiListPrincipalsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Principals
func (a *DefaultAPIService) ListPrincipalsExecute(r ApiListPrincipalsRequest) (*Principals, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Principals
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ListPrincipals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/principals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResetCredentialsRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	principalName string
	resetPrincipalRequest *ResetPrincipalRequest
}

func (r ApiResetCredentialsRequest) ResetPrincipalRequest(resetPrincipalRequest ResetPrincipalRequest) ApiResetCredentialsRequest {
	r.resetPrincipalRequest = &resetPrincipalRequest
	return r
}

func (r ApiResetCredentialsRequest) Execute() (*PrincipalWithCredentials, *http.Response, error) {
	return r.ApiService.ResetCredentialsExecute(r)
}

/*
ResetCredentials Method for ResetCredentials

Reset a principal's credentials to a new set. By default, the system generates random credentials unless explicitly allowed to accept user-provided credentials via configuration.   This API is *not* idempotent and will return the newly created credentials.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param principalName The principal's name
 @return ApiResetCredentialsRequest
*/
func (a *DefaultAPIService) ResetCredentials(ctx context.Context, principalName string) ApiResetCredentialsRequest {
	return ApiResetCredentialsRequest{
		ApiService: a,
		ctx: ctx,
		principalName: principalName,
	}
}

// Execute executes the request
//  @return PrincipalWithCredentials
func (a *DefaultAPIService) ResetCredentialsExecute(r ApiResetCredentialsRequest) (*PrincipalWithCredentials, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PrincipalWithCredentials
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ResetCredentials")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/principals/{principalName}/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"principalName"+"}", url.PathEscape(parameterValueToString(r.principalName, "principalName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.principalName) < 1 {
		return localVarReturnValue, nil, reportError("principalName must have at least 1 elements")
	}
	if strlen(r.principalName) > 256 {
		return localVarReturnValue, nil, reportError("principalName must have less than 256 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resetPrincipalRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRevokeCatalogRoleFromPrincipalRoleRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	principalRoleName string
	catalogName string
	catalogRoleName string
}

func (r ApiRevokeCatalogRoleFromPrincipalRoleRequest) Execute() (*http.Response, error) {
	return r.ApiService.RevokeCatalogRoleFromPrincipalRoleExecute(r)
}

/*
RevokeCatalogRoleFromPrincipalRole Method for RevokeCatalogRoleFromPrincipalRole

Remove a catalog role from a principal role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param principalRoleName The principal role name
 @param catalogName The name of the catalog that contains the role to revoke
 @param catalogRoleName The name of the catalog role that should be revoked
 @return ApiRevokeCatalogRoleFromPrincipalRoleRequest
*/
func (a *DefaultAPIService) RevokeCatalogRoleFromPrincipalRole(ctx context.Context, principalRoleName string, catalogName string, catalogRoleName string) ApiRevokeCatalogRoleFromPrincipalRoleRequest {
	return ApiRevokeCatalogRoleFromPrincipalRoleRequest{
		ApiService: a,
		ctx: ctx,
		principalRoleName: principalRoleName,
		catalogName: catalogName,
		catalogRoleName: catalogRoleName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) RevokeCatalogRoleFromPrincipalRoleExecute(r ApiRevokeCatalogRoleFromPrincipalRoleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RevokeCatalogRoleFromPrincipalRole")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/principal-roles/{principalRoleName}/catalog-roles/{catalogName}/{catalogRoleName}"
	localVarPath = strings.Replace(localVarPath, "{"+"principalRoleName"+"}", url.PathEscape(parameterValueToString(r.principalRoleName, "principalRoleName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"catalogName"+"}", url.PathEscape(parameterValueToString(r.catalogName, "catalogName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"catalogRoleName"+"}", url.PathEscape(parameterValueToString(r.catalogRoleName, "catalogRoleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.principalRoleName) < 1 {
		return nil, reportError("principalRoleName must have at least 1 elements")
	}
	if strlen(r.principalRoleName) > 256 {
		return nil, reportError("principalRoleName must have less than 256 elements")
	}
	if strlen(r.catalogName) < 1 {
		return nil, reportError("catalogName must have at least 1 elements")
	}
	if strlen(r.catalogName) > 256 {
		return nil, reportError("catalogName must have less than 256 elements")
	}
	if strlen(r.catalogRoleName) < 1 {
		return nil, reportError("catalogRoleName must have at least 1 elements")
	}
	if strlen(r.catalogRoleName) > 256 {
		return nil, reportError("catalogRoleName must have less than 256 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRevokeGrantFromCatalogRoleRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	catalogName string
	catalogRoleName string
	cascade *bool
	revokeGrantRequest *RevokeGrantRequest
}

// If true, the grant revocation cascades to all subresources.
func (r ApiRevokeGrantFromCatalogRoleRequest) Cascade(cascade bool) ApiRevokeGrantFromCatalogRoleRequest {
	r.cascade = &cascade
	return r
}

func (r ApiRevokeGrantFromCatalogRoleRequest) RevokeGrantRequest(revokeGrantRequest RevokeGrantRequest) ApiRevokeGrantFromCatalogRoleRequest {
	r.revokeGrantRequest = &revokeGrantRequest
	return r
}

func (r ApiRevokeGrantFromCatalogRoleRequest) Execute() (*http.Response, error) {
	return r.ApiService.RevokeGrantFromCatalogRoleExecute(r)
}

/*
RevokeGrantFromCatalogRole Method for RevokeGrantFromCatalogRole

Delete a specific grant from the role. This may be a subset or a superset of the grants the role has. In case of a subset, the role will retain the grants not specified. If the `cascade` parameter is true, grant revocation will have a cascading effect - that is, if a principal has specific grants on a subresource, and grants are revoked on a parent resource, the grants present on the subresource will be revoked as well. By default, this behavior is disabled and grant revocation only affects the specified resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catalogName The name of the catalog where the role will receive the grant
 @param catalogRoleName The name of the role receiving the grant (must exist)
 @return ApiRevokeGrantFromCatalogRoleRequest
*/
func (a *DefaultAPIService) RevokeGrantFromCatalogRole(ctx context.Context, catalogName string, catalogRoleName string) ApiRevokeGrantFromCatalogRoleRequest {
	return ApiRevokeGrantFromCatalogRoleRequest{
		ApiService: a,
		ctx: ctx,
		catalogName: catalogName,
		catalogRoleName: catalogRoleName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) RevokeGrantFromCatalogRoleExecute(r ApiRevokeGrantFromCatalogRoleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RevokeGrantFromCatalogRole")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalogs/{catalogName}/catalog-roles/{catalogRoleName}/grants"
	localVarPath = strings.Replace(localVarPath, "{"+"catalogName"+"}", url.PathEscape(parameterValueToString(r.catalogName, "catalogName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"catalogRoleName"+"}", url.PathEscape(parameterValueToString(r.catalogRoleName, "catalogRoleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.catalogName) < 1 {
		return nil, reportError("catalogName must have at least 1 elements")
	}
	if strlen(r.catalogName) > 256 {
		return nil, reportError("catalogName must have less than 256 elements")
	}
	if strlen(r.catalogRoleName) < 1 {
		return nil, reportError("catalogRoleName must have at least 1 elements")
	}
	if strlen(r.catalogRoleName) > 256 {
		return nil, reportError("catalogRoleName must have less than 256 elements")
	}

	if r.cascade != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cascade", r.cascade, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "cascade", defaultValue, "form", "")
        r.cascade = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.revokeGrantRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRevokePrincipalRoleRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	principalName string
	principalRoleName string
}

func (r ApiRevokePrincipalRoleRequest) Execute() (*http.Response, error) {
	return r.ApiService.RevokePrincipalRoleExecute(r)
}

/*
RevokePrincipalRole Method for RevokePrincipalRole

Remove a role from a catalog principal

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param principalName The name of the target principal
 @param principalRoleName The name of the role
 @return ApiRevokePrincipalRoleRequest
*/
func (a *DefaultAPIService) RevokePrincipalRole(ctx context.Context, principalName string, principalRoleName string) ApiRevokePrincipalRoleRequest {
	return ApiRevokePrincipalRoleRequest{
		ApiService: a,
		ctx: ctx,
		principalName: principalName,
		principalRoleName: principalRoleName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) RevokePrincipalRoleExecute(r ApiRevokePrincipalRoleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RevokePrincipalRole")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/principals/{principalName}/principal-roles/{principalRoleName}"
	localVarPath = strings.Replace(localVarPath, "{"+"principalName"+"}", url.PathEscape(parameterValueToString(r.principalName, "principalName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"principalRoleName"+"}", url.PathEscape(parameterValueToString(r.principalRoleName, "principalRoleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.principalName) < 1 {
		return nil, reportError("principalName must have at least 1 elements")
	}
	if strlen(r.principalName) > 256 {
		return nil, reportError("principalName must have less than 256 elements")
	}
	if strlen(r.principalRoleName) < 1 {
		return nil, reportError("principalRoleName must have at least 1 elements")
	}
	if strlen(r.principalRoleName) > 256 {
		return nil, reportError("principalRoleName must have less than 256 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRotateCredentialsRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	principalName string
}

func (r ApiRotateCredentialsRequest) Execute() (*PrincipalWithCredentials, *http.Response, error) {
	return r.ApiService.RotateCredentialsExecute(r)
}

/*
RotateCredentials Method for RotateCredentials

Rotate a principal's credentials. The new credentials will be returned in the response. This is the only API, aside from createPrincipal, that returns the user's credentials. This API is *not* idempotent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param principalName The user name
 @return ApiRotateCredentialsRequest
*/
func (a *DefaultAPIService) RotateCredentials(ctx context.Context, principalName string) ApiRotateCredentialsRequest {
	return ApiRotateCredentialsRequest{
		ApiService: a,
		ctx: ctx,
		principalName: principalName,
	}
}

// Execute executes the request
//  @return PrincipalWithCredentials
func (a *DefaultAPIService) RotateCredentialsExecute(r ApiRotateCredentialsRequest) (*PrincipalWithCredentials, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PrincipalWithCredentials
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RotateCredentials")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/principals/{principalName}/rotate"
	localVarPath = strings.Replace(localVarPath, "{"+"principalName"+"}", url.PathEscape(parameterValueToString(r.principalName, "principalName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.principalName) < 1 {
		return localVarReturnValue, nil, reportError("principalName must have at least 1 elements")
	}
	if strlen(r.principalName) > 256 {
		return localVarReturnValue, nil, reportError("principalName must have less than 256 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCatalogRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	catalogName string
	updateCatalogRequest *UpdateCatalogRequest
}

// The catalog details to use in the update
func (r ApiUpdateCatalogRequest) UpdateCatalogRequest(updateCatalogRequest UpdateCatalogRequest) ApiUpdateCatalogRequest {
	r.updateCatalogRequest = &updateCatalogRequest
	return r
}

func (r ApiUpdateCatalogRequest) Execute() (*Catalog, *http.Response, error) {
	return r.ApiService.UpdateCatalogExecute(r)
}

/*
UpdateCatalog Method for UpdateCatalog

Update an existing catalog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catalogName The name of the catalog
 @return ApiUpdateCatalogRequest
*/
func (a *DefaultAPIService) UpdateCatalog(ctx context.Context, catalogName string) ApiUpdateCatalogRequest {
	return ApiUpdateCatalogRequest{
		ApiService: a,
		ctx: ctx,
		catalogName: catalogName,
	}
}

// Execute executes the request
//  @return Catalog
func (a *DefaultAPIService) UpdateCatalogExecute(r ApiUpdateCatalogRequest) (*Catalog, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Catalog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UpdateCatalog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalogs/{catalogName}"
	localVarPath = strings.Replace(localVarPath, "{"+"catalogName"+"}", url.PathEscape(parameterValueToString(r.catalogName, "catalogName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.catalogName) < 1 {
		return localVarReturnValue, nil, reportError("catalogName must have at least 1 elements")
	}
	if strlen(r.catalogName) > 256 {
		return localVarReturnValue, nil, reportError("catalogName must have less than 256 elements")
	}
	if r.updateCatalogRequest == nil {
		return localVarReturnValue, nil, reportError("updateCatalogRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateCatalogRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCatalogRoleRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	catalogName string
	catalogRoleName string
	updateCatalogRoleRequest *UpdateCatalogRoleRequest
}

func (r ApiUpdateCatalogRoleRequest) UpdateCatalogRoleRequest(updateCatalogRoleRequest UpdateCatalogRoleRequest) ApiUpdateCatalogRoleRequest {
	r.updateCatalogRoleRequest = &updateCatalogRoleRequest
	return r
}

func (r ApiUpdateCatalogRoleRequest) Execute() (*CatalogRole, *http.Response, error) {
	return r.ApiService.UpdateCatalogRoleExecute(r)
}

/*
UpdateCatalogRole Method for UpdateCatalogRole

Update an existing role in the catalog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catalogName The catalog for which we are retrieving roles
 @param catalogRoleName The name of the role
 @return ApiUpdateCatalogRoleRequest
*/
func (a *DefaultAPIService) UpdateCatalogRole(ctx context.Context, catalogName string, catalogRoleName string) ApiUpdateCatalogRoleRequest {
	return ApiUpdateCatalogRoleRequest{
		ApiService: a,
		ctx: ctx,
		catalogName: catalogName,
		catalogRoleName: catalogRoleName,
	}
}

// Execute executes the request
//  @return CatalogRole
func (a *DefaultAPIService) UpdateCatalogRoleExecute(r ApiUpdateCatalogRoleRequest) (*CatalogRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CatalogRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UpdateCatalogRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalogs/{catalogName}/catalog-roles/{catalogRoleName}"
	localVarPath = strings.Replace(localVarPath, "{"+"catalogName"+"}", url.PathEscape(parameterValueToString(r.catalogName, "catalogName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"catalogRoleName"+"}", url.PathEscape(parameterValueToString(r.catalogRoleName, "catalogRoleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.catalogName) < 1 {
		return localVarReturnValue, nil, reportError("catalogName must have at least 1 elements")
	}
	if strlen(r.catalogName) > 256 {
		return localVarReturnValue, nil, reportError("catalogName must have less than 256 elements")
	}
	if strlen(r.catalogRoleName) < 1 {
		return localVarReturnValue, nil, reportError("catalogRoleName must have at least 1 elements")
	}
	if strlen(r.catalogRoleName) > 256 {
		return localVarReturnValue, nil, reportError("catalogRoleName must have less than 256 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateCatalogRoleRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePrincipalRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	principalName string
	updatePrincipalRequest *UpdatePrincipalRequest
}

// The principal details to use in the update
func (r ApiUpdatePrincipalRequest) UpdatePrincipalRequest(updatePrincipalRequest UpdatePrincipalRequest) ApiUpdatePrincipalRequest {
	r.updatePrincipalRequest = &updatePrincipalRequest
	return r
}

func (r ApiUpdatePrincipalRequest) Execute() (*Principal, *http.Response, error) {
	return r.ApiService.UpdatePrincipalExecute(r)
}

/*
UpdatePrincipal Method for UpdatePrincipal

Update an existing principal

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param principalName The principal name
 @return ApiUpdatePrincipalRequest
*/
func (a *DefaultAPIService) UpdatePrincipal(ctx context.Context, principalName string) ApiUpdatePrincipalRequest {
	return ApiUpdatePrincipalRequest{
		ApiService: a,
		ctx: ctx,
		principalName: principalName,
	}
}

// Execute executes the request
//  @return Principal
func (a *DefaultAPIService) UpdatePrincipalExecute(r ApiUpdatePrincipalRequest) (*Principal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Principal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UpdatePrincipal")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/principals/{principalName}"
	localVarPath = strings.Replace(localVarPath, "{"+"principalName"+"}", url.PathEscape(parameterValueToString(r.principalName, "principalName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.principalName) < 1 {
		return localVarReturnValue, nil, reportError("principalName must have at least 1 elements")
	}
	if strlen(r.principalName) > 256 {
		return localVarReturnValue, nil, reportError("principalName must have less than 256 elements")
	}
	if r.updatePrincipalRequest == nil {
		return localVarReturnValue, nil, reportError("updatePrincipalRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updatePrincipalRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePrincipalRoleRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	principalRoleName string
	updatePrincipalRoleRequest *UpdatePrincipalRoleRequest
}

// The principalRole details to use in the update
func (r ApiUpdatePrincipalRoleRequest) UpdatePrincipalRoleRequest(updatePrincipalRoleRequest UpdatePrincipalRoleRequest) ApiUpdatePrincipalRoleRequest {
	r.updatePrincipalRoleRequest = &updatePrincipalRoleRequest
	return r
}

func (r ApiUpdatePrincipalRoleRequest) Execute() (*PrincipalRole, *http.Response, error) {
	return r.ApiService.UpdatePrincipalRoleExecute(r)
}

/*
UpdatePrincipalRole Method for UpdatePrincipalRole

Update an existing principalRole

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param principalRoleName The principal role name
 @return ApiUpdatePrincipalRoleRequest
*/
func (a *DefaultAPIService) UpdatePrincipalRole(ctx context.Context, principalRoleName string) ApiUpdatePrincipalRoleRequest {
	return ApiUpdatePrincipalRoleRequest{
		ApiService: a,
		ctx: ctx,
		principalRoleName: principalRoleName,
	}
}

// Execute executes the request
//  @return PrincipalRole
func (a *DefaultAPIService) UpdatePrincipalRoleExecute(r ApiUpdatePrincipalRoleRequest) (*PrincipalRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PrincipalRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UpdatePrincipalRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/principal-roles/{principalRoleName}"
	localVarPath = strings.Replace(localVarPath, "{"+"principalRoleName"+"}", url.PathEscape(parameterValueToString(r.principalRoleName, "principalRoleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.principalRoleName) < 1 {
		return localVarReturnValue, nil, reportError("principalRoleName must have at least 1 elements")
	}
	if strlen(r.principalRoleName) > 256 {
		return localVarReturnValue, nil, reportError("principalRoleName must have less than 256 elements")
	}
	if r.updatePrincipalRoleRequest == nil {
		return localVarReturnValue, nil, reportError("updatePrincipalRoleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updatePrincipalRoleRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
